#' @title plotGeneCoverage
#' @param IP_BAM The bam files for IP samples
#' @param INPUT_BAM The bam files for INPUT samples
#' @param size.IP The size factor for IP libraries
#' @param size.INPUT The size factor for INPUT libraries
#' @param geneName The name (as defined in gtf file) of the gene you want to plot
#' @param geneModel The gene model generated by gtfToGeneModel() function
#' @param libraryType "opposite" for mRNA stranded library, "same" for samll RNA library
#' @param GTF gtf annotation as GRanges object. Can be obtained by GTF <- rtracklayer::import("xxx.gtf",format = "gtf")
#' @param adjustExprLevel Logic parameter determining whether adjust coverage so that input are at "same" expression level.
#' @param plotSNP The option to plot SNP on the figure. Null by default. If want to include SNP in the plot, the parameter needs to ba a dataframe like this:  data.frame(loc= position, anno="A/G")
#' @export
plotGeneCoverage <- function(IP_BAMs, INPUT_BAMs, size.IP, size.INPUT,X, geneName, geneModel, libraryType = "opposite", center = mean ,GTF,ZoomIn=NULL, adjustExprLevel = FALSE, plotSNP = NULL){
  
  registerDoParallel( length(levels(X)) )
  INPUT.cov <- foreach(ii = levels(X),.combine = cbind)%dopar%{
    getAveCoverage(geneModel= geneModel,bamFiles = INPUT_BAMs[X==ii],geneName = geneName,size.factor = size.INPUT[X==ii], libraryType = libraryType, center = center,ZoomIn = ZoomIn)
    }
  IP.cov <- foreach(ii = levels(X),.combine = cbind)%dopar%{
    getAveCoverage(geneModel= geneModel,bamFiles = IP_BAMs[X==ii],geneName = geneName,size.factor = size.IP[X==ii], libraryType = libraryType, center = center, ZoomIn = ZoomIn)
  }
  rm(list=ls(name=foreach:::.foreachGlobals), pos=foreach:::.foreachGlobals)
  
  if(adjustExprLevel){
    cov.size <- colSums(INPUT.cov)/mean(colSums(INPUT.cov))
    INPUT.cov <- t(  t(INPUT.cov)/cov.size )
    IP.cov <- t( t(IP.cov)/cov.size )
  }
  
  cov.data <- data.frame(genome_location=rep(as.numeric(rownames(IP.cov) ),length(levels(X))), 
                         IP=c(IP.cov),Input=c(INPUT.cov),
                         Group = factor( rep(levels(X),rep(nrow(IP.cov),length(levels(X)) ) ), levels = levels(X) )
                         )
  yscale <- max(IP.cov,INPUT.cov)
  
  chr <- unique(as.character(as.data.frame(geneModel[geneName])$seqnames))
  
  p1 <- "ggplot(data = cov.data,aes(genome_location))+geom_line(aes(y=Input,colour =Group))+geom_ribbon(aes(ymax = IP,ymin=0,fill=Group), alpha = 0.4)+labs(y=\"normalized coverage\",x = paste0( \"Genome location on chromosome: \", chr) )+scale_x_continuous(breaks = round(seq(min(cov.data$genome_location), max(cov.data$genome_location), by = ((max(cov.data$genome_location)-min(cov.data$genome_location))/10) )))+theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(), axis.line = element_line(colour = \"black\"),axis.title = element_text(face = \"bold\"),axis.text = element_text(face = \"bold\") ) + scale_fill_discrete(name=\"IP\") + scale_colour_discrete(name=\"INPUT\")"
  
  p2 <- .getGeneModelAnno(geneModel,geneName,GTF,ZoomIn)
  
  ## handle the option of plot the SNP in the gene model. 
  if(is.null(plotSNP) ){
    p <- paste(p1,p2,sep = "+")
  }else{
    
    ## if the SNP is outside of the gene
    if(plotSNP$loc >max(cov.data$genome_location) ){
      
      plotSNP_new <- max(cov.data$genome_location) + 0.025*length(cov.data$genome_location)
      p3 <- "annotate(\"rect\",xmin = ( plotSNP_new -2 ), xmax = ( plotSNP_new +2 ) , ymin = -0.08*yscale, ymax = -0.02*yscale, alpha = .99, colour = \"red\")+
       annotate(\"text\", ,x=plotSNP_new, y = -0.1*yscale, label= paste0(  chr,\":\",as.character(plotSNP$loc)), alpha = .99, colour = \"black\")+
       annotate(\"text\", ,x=plotSNP_new, y = 0, label=as.character(plotSNP$anno), alpha = .99, colour = \"blue\")"
      p <- paste(p1,p2,p3,sep = "+")
      
    }else if( plotSNP$loc<min(cov.data$genome_location) ){
      
      plotSNP_new <- max(cov.data$genome_location) - 0.025*length(cov.data$genome_location)
      p3 <- "annotate(\"rect\",xmin = ( plotSNP_new -2 ), xmax = ( plotSNP_new +2 ) , ymin = -0.08*yscale, ymax = -0.02*yscale, alpha = .99, colour = \"red\")+
       annotate(\"text\", ,x=plotSNP_new, y = -0.1*yscale, label= paste0(  chr,\":\",as.character(plotSNP$loc)), alpha = .99, colour = \"black\")+
       annotate(\"text\", ,x=plotSNP_new, y = 0, label=as.character(plotSNP$anno), alpha = .99, colour = \"blue\")"
      p <- paste(p1,p2,p3,sep = "+")
      
    }else{ ## if the SNP is within the gene
       p3 <- "annotate(\"rect\",xmin = (plotSNP$loc-2 ), xmax = ( plotSNP$loc+2 ) , ymin = -0.08*yscale, ymax = -0.02*yscale, alpha = .99, colour = \"red\")+
       annotate(\"text\", ,x=plotSNP$loc, y = -0.1*yscale, label=as.character(plotSNP$anno), alpha = .99, colour = \"blue\")"
       p <- paste(p1,p2,p3,sep = "+")
    }
   
  }
  
  eval(parse( text = p ))
}


#' @title plotVirusCov
#' @param IP_BAM The bam files for IP samples
#' @param INPUT_BAM The bam files for INPUT samples
#' @param geneModel The GRange object storing positive and negative strand as gene model of the virus.
#' @param libraryType The specification of strandness of the RNA library. "opposite" for mRNA stranded library that sequenced the reverse complementary strand; "same" for samll RNA library that sequenced the same strand. 
#' @param center The function used to calculate the center of multiple replicates. Can be mean or median.
#' @param annotation The data.frame specify the genes on the viral genome. Needs to have column "chr", "start", "end", "gene".
#' @param ZoomIn The range to plot the coverage. 
#' @param hideStrand The strand to hide when plot. Default is none.
#' @export
plotVirusCov <- function(IP_BAM, INPUT_BAM,geneModel,libraryType = "opposite",center = mean,annotation, ZoomIn = NULL, hideStrand = "none"){
  #########################
  ### Generage gene model #
  #########################
  ## convert annotation into GRange
  anno.gr <- makeGRangesFromDataFrame(annotation,keep.extra.columns = T)
  
  anno.exon <- character(length =nrow(annotation))
  for(i in 1:nrow(annotation)){
    anno.exon[i] <- paste0("annotate(\"rect\", xmin =",annotation$start[i] ,", xmax = ",annotation$end[i] ,", ymin = -0.06*yscale, ymax = -0*yscale, alpha = .99, colour = \"black\")+ annotate(\"text\", x = mean(c(",annotation$start[i],",",annotation$end[i],")), y = -0.03*yscale, label = \"",annotation$gene[i],"\", colour = \"yellow\")" )
  }
  
  pseudo_intron <- as.data.frame( GenomicRanges::setdiff(geneModel[[1]],anno.gr,ignore.strand=T) )
  anno.intron <- character(length =nrow(pseudo_intron))
  for(i in 1:nrow(pseudo_intron)){
    anno.intron[i] <- paste0("annotate(\"segment\", x =",pseudo_intron$start[i] ,", xend = ",pseudo_intron$end[i] ,", y = -0.03*yscale, yend = -0.03*yscale, alpha = .99, colour = \"black\", size = 1) " )
  }
  
  p2 <- paste( paste(anno.exon,collapse = "+"), paste(anno.intron,collapse = "+"), sep = "+")
  
  ###########################
  ## Generate coverage ######
  ###########################
  ## Positive strand
  genePositive <- names(geneModel[which( as.character(strand(geneModel) )== "+")])
  IP.cov_positive <- getAllCoverage(geneModel= geneModel,bamFiles = IP_BAM,geneName = genePositive, libraryType = libraryType, ZoomIn = ZoomIn)
  INPUT.cov_positive <- getAllCoverage(geneModel= geneModel,bamFiles = INPUT_BAM,geneName = genePositive, libraryType = libraryType, ZoomIn = ZoomIn)
  cov.data_positive <-  cbind(IP.cov_positive,INPUT.cov_positive) 
  
  ## Normalized positive strand
  size.positive <- colSums(cov.data_positive)/ mean( colSums(cov.data_positive))
  cov.data_positive.norm <- t( t(cov.data_positive)/ size.positive )
  
  ## Negative strand
  geneNegative <- names(geneModel[which( as.character(strand(geneModel) )== "-")])
  IP.cov_Negative <- getAllCoverage(geneModel= geneModel,bamFiles = IP_BAM,geneName = geneNegative, libraryType = libraryType, ZoomIn = ZoomIn)
  INPUT.cov_Negative <- getAllCoverage(geneModel= geneModel,bamFiles = INPUT_BAM,geneName = geneNegative, libraryType = libraryType, ZoomIn = ZoomIn)
  cov.data_Negative <-  cbind(IP.cov_Negative,INPUT.cov_Negative) 
  
  ## Normalized Negative strand
  size.Negative <- colSums(cov.data_Negative)/ mean( colSums(cov.data_Negative))
  cov.data_Negative.norm <- t( t(cov.data_Negative)/ size.Negative )
  
  ## get average from replicates
  X <- c(rep("IP",length(IP_BAM)),rep("INPUT",length(INPUT_BAM)))
  mean_norm_positive <- data.frame( t( apply(cov.data_positive.norm,1,tapply,X,mean) ) )
  mean_norm_negative <- data.frame( t( apply(cov.data_Negative.norm,1,tapply,X,mean) ) )
  colnames(mean_norm_negative) <-paste0(colnames(mean_norm_negative),".neg")
  
  cov.data <- dplyr::mutate(genome_location = 1:nrow(mean_norm_negative) , cbind(mean_norm_positive,mean_norm_negative) )
  
  yscale <- max(mean_norm_positive,mean_norm_negative)
  
  p1 <- "ggplot(data = cov.data,aes(genome_location))"
  
  if(hideStrand == "none"){
    p3 <- "geom_line(aes(y=INPUT,colour = \"+\"))+geom_ribbon(aes(ymax = IP,ymin=0,fill = \"+\"), alpha = 0.4)+geom_line(aes(y=(-INPUT.neg-0.06*yscale),colour = \"-\"))+geom_ribbon(aes(ymax = -0.06*yscale,ymin=(-IP.neg-0.06*yscale),fill = \"-\"), alpha = 0.4) +labs(y=\"normalized coverage\")+scale_x_continuous(breaks = round(seq(min(cov.data$genome_location), max(cov.data$genome_location), by = ((max(cov.data$genome_location)-min(cov.data$genome_location))/10) ) ),expand = c(0,0) )+theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = \"black\") )+scale_y_continuous(expand = c(0, 0))+scale_fill_discrete(name=\"IP\") + scale_colour_discrete(name=\"INPUT\")"
  }else if(hideStrand == "+"){
    p3 <- "geom_line(aes(y=(-INPUT.neg-0.06*yscale),colour = \"-\"))+geom_ribbon(aes(ymax = -0.06*yscale,ymin=(-IP.neg-0.06*yscale),fill = \"-\"), alpha = 0.4) +labs(y=\"normalized coverage\")+scale_x_continuous(breaks = round(seq(min(cov.data$genome_location), max(cov.data$genome_location), by = ((max(cov.data$genome_location)-min(cov.data$genome_location))/10) ) ),expand = c(0,0) )+theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = \"black\") )+scale_y_continuous(expand = c(0, 0))+scale_fill_discrete(name=\"IP\") + scale_colour_discrete(name=\"INPUT\")"
  }else if(hideStrand == "-"){
    p3 <- "geom_line(aes(y=INPUT,colour = \"+\"))+geom_ribbon(aes(ymax = IP,ymin=0,fill = \"+\"), alpha = 0.4)+labs(y=\"normalized coverage\")+scale_x_continuous(breaks = round(seq(min(cov.data$genome_location), max(cov.data$genome_location), by = ((max(cov.data$genome_location)-min(cov.data$genome_location))/10) ) ),expand = c(0,0) )+theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = \"black\") )+scale_y_continuous(expand = c(0, 0))+scale_fill_discrete(name=\"IP\") + scale_colour_discrete(name=\"INPUT\")"
  }else{ stop("Please specify strand to be hide as \"+\", \"-\" or \"none\" !! ")}
  
  p <- paste(p1,p2,p3,sep = "+")
  
  eval(parse( text = p ))
}

## helper function to get average coverage of a gene of multiple samples
getAveCoverage <- function(geneModel,bamFiles,geneName,size.factor, libraryType = libraryType, center ,ZoomIn){
  locus <- as.data.frame( range(geneModel[geneName][[1]]) )
  if(is.null(ZoomIn)){
  }else{
    locus$start = ZoomIn[1]
    locus$end = ZoomIn[2]
    locus$width = ZoomIn[2] - ZoomIn[1] + 1
  }
  covs <- sapply(bamFiles,getCov,locus=locus, libraryType = libraryType)
  covs <- t( t(covs)/size.factor )
  ave.cov <- apply(covs,1, center)
  return(ave.cov)
}

getCov <- function(bf,locus, libraryType ){
  s_param <- ScanBamParam(which = GRanges(locus$seqnames,IRanges(locus$start,locus$end)))
  p_param <- PileupParam(max_depth=1000000,min_nucleotide_depth=0,distinguish_nucleotides=F)
  #get coverage from the bam file
  res <- pileup(bf,scanBamParam = s_param,pileupParam = p_param)
  if(libraryType == "opposite"){
    res <- res[res$strand!=locus$strand,]
  }else if (libraryType == "same"){
    res <- res[res$strand==locus$strand,]
  }else{
    stop("libraryType must be opposite or same... ")
  }
  cov <- vector(length = locus$width)
  names(cov) <- c(locus$start:locus$end)
  cov[1:locus$width] <- 0
  cov[res$pos-locus$start+1] <- res$count
  return(cov)
}

.getGeneModelAnno <- function(geneModel,geneName,gtf_grange,zoomIn = NULL){
  exon.current <- reduce( geneModel[geneName][[1]] )
  startCodon <-  reduce( gtf_grange[gtf_grange$type == "start_codon" & gtf_grange$gene_id == geneName] )
  stopCodon <- reduce( gtf_grange[gtf_grange$type == "stop_codon" & gtf_grange$gene_id == geneName] )
  if(as.logical(strand(exon.current)[1]=="-")){
    startCodon <- startCodon[which.max( start(startCodon) )]
    stopCodon <- stopCodon[which.min( start(stopCodon) )]
    cdsRange <- stopCodon
    end(cdsRange) <- end(startCodon)
    cds.current <- suppressWarnings( GenomicRanges::intersect(exon.current,cdsRange) )
  }else{
    startCodon <- startCodon[which.min( start(startCodon) )]
    stopCodon <- stopCodon[which.max( start(stopCodon) )]
    cdsRange <- startCodon
    end(cdsRange) <- end(stopCodon)
    cds.current <- suppressWarnings( GenomicRanges::intersect(exon.current,cdsRange) )
  }
  utr.current <- GenomicRanges::setdiff(exon.current,cds.current)
  exon.new <- sort( c(cds.current,utr.current) )
  
  if(is.null(zoomIn)){
    cds.id <- unique( queryHits( findOverlaps(exon.new, cds.current)) )
    df.exon <- as.data.frame(exon.new)
    anno.exon <- character(length = length(exon.new))
    anno.intron <- character(length = length(exon.new)-1 )
    for(i in 1:length(exon.new)){
      if( i %in% cds.id){
        anno.exon[i] <- paste0("annotate(\"rect\", xmin =",df.exon$start[i] ,", xmax = ",df.exon$end[i] ,", ymin = -0.08*yscale, ymax = -0.02*yscale, alpha = .99, colour = \"black\")" )
      }else{
        anno.exon[i] <- paste0("annotate(\"rect\",xmin =",df.exon$start[i] ,", xmax = ",df.exon$end[i] ,", ymin = -0.06*yscale, ymax = -0.04*yscale, alpha = .99, colour = \"black\")")
      }
    }
    if(length(anno.intron)>0){
      for(i in 1:length(anno.intron)){
        anno.intron[i] <- paste0("annotate(\"segment\", x =", df.exon$end[i] ,", xend =", df.exon$start[i+1] ,", y = -0.05*yscale, yend = -0.05*yscale, alpha = .99, colour = \"black\")")
      }
      p <- paste( paste(anno.exon,collapse = "+"), paste(anno.intron,collapse = "+"), sep = "+")
    }else{
      p <-paste(anno.exon,collapse = "+")
    }
    
    
    return(p)
    
  }else{
    zoomIn.gr <- exon.new[1]
    ranges(zoomIn.gr) <- IRanges(start = zoomIn[1],end = zoomIn[2])
    exon.zoom <- GenomicRanges::intersect(exon.new, zoomIn.gr)
    cds.current.zoom <- GenomicRanges::intersect(exon.zoom, cds.current)
    utr.current.zoom <- GenomicRanges::setdiff(exon.zoom,cds.current.zoom)
    exon.zoom.new <-  sort( c(cds.current.zoom,utr.current.zoom) )
    
    cds.id <- unique( queryHits( findOverlaps(exon.zoom.new, cds.current.zoom)) )
    df.exon <- as.data.frame(exon.zoom.new)
    anno.exon <- character(length = length(exon.zoom))
    ## add exon plot if # exon > 0
    if(length(exon.zoom.new) > 0){
      for(i in 1:length(exon.zoom.new)){
        if( i %in% cds.id){
          anno.exon[i] <- paste0("annotate(\"rect\", xmin =",df.exon$start[i] ,", xmax = ",df.exon$end[i] ,", ymin = -0.08*yscale, ymax = -0.02*yscale, alpha = .99, colour = \"black\")" )
        }else{
          anno.exon[i] <- paste0("annotate(\"rect\",xmin =",df.exon$start[i] ,", xmax = ",df.exon$end[i] ,", ymin = -0.06*yscale, ymax = -0.04*yscale, alpha = .99, colour = \"black\")")
        }
      }
    }
    
    ## plot intron when there are more than two exons
    anno.intron <- character(length = max( length(exon.zoom.new)-1, 0 )  )
    if(length(anno.intron)>0){
      for(i in 1:length(anno.intron)){
        anno.intron[i] <- paste0("annotate(\"segment\", x =", df.exon$end[i] ,", xend =", df.exon$start[i+1] ,", y = -0.05*yscale, yend = -0.05*yscale, alpha = .99, colour = \"black\")")
      }
    }
    ## When there is only one exon and zoomIn range spans intron
    if( length(exon.zoom.new) > 0 && start(zoomIn.gr)<start(exon.zoom)[1]){
      anno.intron <- c(paste0("annotate(\"segment\", x =", start(zoomIn.gr) ,", xend =", start(exon.zoom)[1] ,", y = -0.05*yscale, yend = -0.05*yscale, alpha = .99, colour = \"black\")"),
                       anno.intron)
    }
    if( length(exon.zoom.new) > 0 && end(zoomIn.gr) > end(exon.zoom)[length(exon.zoom)] ){
      anno.intron <- c(anno.intron,
                       paste0("annotate(\"segment\", x =", end(exon.zoom)[length(exon.zoom)] ,", xend =", end(zoomIn.gr) ,", y = -0.05*yscale, yend = -0.05*yscale, alpha = .99, colour = \"black\")") )
    }
    ## When there is no exon but zoomIn ranges is in intron
    if( length(exon.zoom.new) == 0 ){
      anno.intron <- c(anno.intron,
                       paste0("annotate(\"segment\", x =", start(zoomIn.gr) ,", xend =", end(zoomIn.gr) ,", y = -0.05*yscale, yend = -0.05*yscale, alpha = .99, colour = \"black\")") )
    }
    
    ## combine intron and exon plots
    if( length(anno.intron) > 0 & length(anno.exon) >0 ){
      p <- paste( paste(anno.exon,collapse = "+"), paste(anno.intron,collapse = "+"), sep = "+")
    }else if( length(anno.exon) >0 ){
      p <- paste(anno.exon,collapse = "+")
    }else{
      p <- paste(anno.intron,collapse = "+")
    }
    
    return(p)
  }
  
}




getAllCoverage <- function(geneModel,bamFiles,geneName, libraryType = libraryType ,ZoomIn){
  locus <- as.data.frame( range(geneModel[geneName][[1]]) )
  if(is.null(ZoomIn)){
  }else{
    locus$start = ZoomIn[1]
    locus$end = ZoomIn[2]
    locus$width = ZoomIn[2] - ZoomIn[1] + 1
  }
  covs <- sapply(bamFiles,getCov,locus=locus, libraryType = libraryType)
  
  return(covs)
}
